<!DOCTYPE html>
<html lang="pt-br">
	<head>
		<meta charset="UTF-8" />
		<title>Super Mario Paris - Versão Final Legível</title>
		<style>
			body {
				margin: 0;
				overflow: hidden;
				background: #202020;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				font-family: "Courier New", Courier, monospace;
			}
			#gameContainer {
				position: relative;
				width: 800px;
				height: 600px;
				box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
				border: 4px solid #fff;
			}
			canvas {
				background-color: #87ceeb;
				display: block;
				width: 100%;
				height: 100%;
			}
			/* ESTILO DO VÍDEO (Escondido inicialmente) */
			#endingVideo {
				display: none;
				width: 100%;
				height: 100%;
				object-fit: cover;
				background: black;
				position: absolute;
				top: 0;
				left: 0;
				z-index: 100;
			}
			/* CAPA E INSTRUÇÕES */
			#startScreen {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-image: url("cover.png");
				background-size: cover;
				background-position: center;
				z-index: 50;
				cursor: pointer;
			}
			#instructions {
				position: absolute;
				top: 10px;
				width: 100%;
				color: #fff;
				text-shadow: 2px 2px 0px #000;
				text-align: center;
				pointer-events: none;
				font-size: 18px;
				font-weight: bold;
				z-index: 60;
			}
		</style>
	</head>
	<body>
		<div id="gameContainer">
			<div id="startScreen"></div>
			<div id="instructions">ARROWS: Move/Jump | COLLECT 20 COINS!</div>
			<video
				id="endingVideo"
				src="ending2.mp4"
				style="
					display: none;
					position: absolute;
					top: 0;
					left: 0;
					width: 800px;
					height: 600px;
					object-fit: cover;
					z-index: 100;
				"
			></video>
			<canvas id="gameCanvas"></canvas>
		</div>
		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");

			const videoElement = document.getElementById("endingVideo");

			canvas.width = 800;
			canvas.height = 600;

			// =================================================================
			// 0. GERENCIADOR DE ÁUDIO
			// =================================================================
			class AudioHandler {
				constructor() {
					// Músicas (.mp3)
					this.bgMusic = new Audio("./audio/background.mp3");
					this.bgMusic.loop = true;
					this.bgMusic.volume = 0.3;

					this.peachMusic = new Audio("./audio/peach_theme.mp3");
					this.peachMusic.loop = true;
					this.peachMusic.volume = 0.4;

					// Efeitos Sonoros (.wav)
					this.jumpSound = new Audio("./audio/jump.wav");
					this.jumpSound.volume = 0.4;

					this.gameOverSound = new Audio("./audio/gameover.wav");
					this.gameOverSound.volume = 0.5;

					this.coinSound = new Audio("./audio/coin.wav");
					this.coinSound.volume = 0.3;

					// Controle de Fade Out da Peach
					this.peachFadeInterval = null;
				}

				playPeachTheme() {
					this.peachMusic.volume = 0.4;
					this.peachMusic.currentTime = 0;
					// O catch evita erros se o usuário ainda não clicou na página
					this.peachMusic
						.play()
						.catch((e) => console.log("Aguardando interação..."));
				}

				// Diminui o volume da música da Peach aos poucos
				fadeOutPeachTheme() {
					if (this.peachFadeInterval) return; // Já está diminuindo

					this.peachFadeInterval = setInterval(() => {
						if (this.peachMusic.volume > 0.02) {
							this.peachMusic.volume -= 0.02;
						} else {
							this.peachMusic.pause();
							this.peachMusic.currentTime = 0;
							clearInterval(this.peachFadeInterval);
							this.peachFadeInterval = null;
						}
					}, 100); // A cada 100ms diminui um pouco
				}

				stopPeachThemeImmediate() {
					if (this.peachFadeInterval) {
						clearInterval(this.peachFadeInterval);
						this.peachFadeInterval = null;
					}
					this.peachMusic.pause();
					this.peachMusic.currentTime = 0;
				}

				playMusic() {
					this.bgMusic.volume = 0.3;
					this.bgMusic.currentTime = 0;
					this.bgMusic.play().catch((e) => {});
				}

				stopMusic() {
					this.bgMusic.pause();
					this.bgMusic.currentTime = 0;
				}

				playJump() {
					this.jumpSound.currentTime = 0; // Reinicia o som para pulos rápidos
					this.jumpSound.play().catch((e) => {});
				}

				playCoin() {
					this.coinSound.currentTime = 0;
					this.coinSound.play().catch((e) => {});
				}

				playGameOver() {
					this.stopMusic();
					this.stopPeachThemeImmediate();
					this.gameOverSound.play().catch((e) => {});
				}
			}

			// =================================================================
			// 1. INPUT HANDLER (TECLADO)
			// =================================================================
			class InputHandler {
				constructor() {
					this.keys = [];
					this.hasInteracted = false;

					window.addEventListener("keydown", (e) => {
						if (
							(e.key === "ArrowDown" ||
								e.key === "ArrowUp" ||
								e.key === "ArrowLeft" ||
								e.key === "ArrowRight" ||
								e.key === " ") &&
							this.keys.indexOf(e.key) === -1
						) {
							this.keys.push(e.key);
						}

						// Tenta iniciar a música na primeira tecla apertada (se estiver na intro)
						if (
							!this.hasInteracted &&
							game &&
							game.introState === 1
						) {
							game.audio.playPeachTheme();
							this.hasInteracted = true;
						}
					});

					window.addEventListener("keyup", (e) => {
						if (
							e.key === "ArrowDown" ||
							e.key === "ArrowUp" ||
							e.key === "ArrowLeft" ||
							e.key === "ArrowRight" ||
							e.key === " "
						) {
							this.keys.splice(this.keys.indexOf(e.key), 1);
						}
					});
				}
			}

			// =================================================================
			// 2. CLASSES DE AMBIENTE
			// =================================================================

			// --- CÉU E NUVENS ---
			class Sky {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.image = new Image();
					this.image.src = "cloud.png";
					this.clouds = [];
					this.speedModifier = 0.1;

					// Cria 6 nuvens iniciais
					for (let i = 0; i < 6; i++) {
						this.clouds.push(this.createCloud(true));
					}
				}

				createCloud(randomX = false) {
					const scale = Math.random() * 0.5 + 0.5;
					return {
						x: randomX
							? Math.random() * this.gameWidth
							: this.gameWidth + 10,
						y: Math.random() * (this.gameHeight * 0.4),
						width: 100 * scale,
						height: 60 * scale,
						speed: Math.random() * 0.2 + 0.1,
					};
				}

				update(playerSpeed) {
					this.clouds.forEach((c) => {
						c.x -= c.speed + playerSpeed * this.speedModifier;
					});
					// Remove nuvens que saíram e cria novas
					this.clouds = this.clouds.filter(
						(c) => c.x + c.width > -100
					);
					while (this.clouds.length < 6) {
						this.clouds.push(this.createCloud());
					}
				}

				draw(context) {
					context.fillStyle = "#87CEEB";
					context.fillRect(0, 0, this.gameWidth, this.gameHeight);
					if (this.image.complete) {
						this.clouds.forEach((c) =>
							context.drawImage(
								this.image,
								c.x,
								c.y,
								c.width,
								c.height
							)
						);
					}
				}
			}

			// --- MONUMENTOS (FUNDO DISTANTE) ---
			class Background {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.image = new Image();
					this.image.src = "sprites_env.png";
					this.speedModifier = 0.2;
					this.tileSize = 142;
					this.scale = 1.5;
					this.minGap = 300; // Distância entre monumentos

					// Definição dos monumentos no grid da imagem
					this.monuments = [
						{
							name: "louvre",
							gridX: 0,
							gridY: 5,
							gridW: 11,
							gridH: 3,
						},
						{
							name: "eiffel",
							gridX: 5,
							gridY: 0,
							gridW: 1,
							gridH: 2,
						},
						{
							name: "arco",
							gridX: 11,
							gridY: 1,
							gridW: 2,
							gridH: 2,
						},
						{
							name: "moulin",
							gridX: 0,
							gridY: 0,
							gridW: 4,
							gridH: 3,
						},
						{
							name: "sacre",
							gridX: 6,
							gridY: 0,
							gridW: 5,
							gridH: 3,
						},
					];
					this.initMonuments();
				}

				initMonuments() {
					let currentX = 200;
					this.monuments.forEach((m) => {
						m.drawW = m.gridW * this.tileSize * this.scale;
						m.drawH = m.gridH * this.tileSize * this.scale;
						m.x = currentX;
						currentX += m.drawW + this.minGap;
					});
				}

				update(speed) {
					let realSpeed = speed * this.speedModifier;
					this.monuments.forEach((m) => {
						m.x -= realSpeed;
					});

					// Lógica de carrossel infinito
					this.monuments.forEach((m) => {
						if (m.x + m.drawW < -200) {
							let furthestX = -9999;
							let lastWidth = 0;
							this.monuments.forEach((other) => {
								if (other.x > furthestX) {
									furthestX = other.x;
									lastWidth = other.drawW;
								}
							});
							m.x = furthestX + lastWidth + this.minGap;
						}
					});
				}

				draw(context) {
					if (!this.image.complete) return;
					this.monuments.forEach((m) => {
						// Só desenha se estiver visível
						if (
							m.x + m.drawW > -100 &&
							m.x < this.gameWidth + 100
						) {
							const destY = this.gameHeight - 50 - m.drawH + 50;
							context.drawImage(
								this.image,
								m.gridX * this.tileSize,
								m.gridY * this.tileSize,
								m.gridW * this.tileSize,
								m.gridH * this.tileSize,
								m.x,
								destY,
								m.drawW,
								m.drawH
							);
						}
					});
				}
			}

			// --- PRÉDIOS (FUNDO PRÓXIMO) ---
			class FillerBackground {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.image = new Image();
					this.image.src = "sprites_buildings.png";
					this.speedModifier = 0.5;
					this.scale = 1.2;
					this.buildings = [];
					this.initBuildings();
				}

				initBuildings() {
					let currentX = 0;
					// Preenche 3 telas de largura
					while (currentX < this.gameWidth * 3) {
						this.addBuilding(currentX);
						currentX +=
							this.buildings[this.buildings.length - 1].width;
					}
				}

				addBuilding(x) {
					// Valores fixos baseados na imagem enviada
					let building = {
						x: x,
						y: this.gameHeight - 45 - 216 * 1.2, // Altura do prédio ajustada
						width: 1152 * 1.2, // Largura total ajustada
						height: 216 * 1.2,
						sx: 0,
						sy: 0,
						sw: 1152,
						sh: 216, // Recorte original
						img: this.image,
					};
					this.buildings.push(building);
				}

				update(speed) {
					let realSpeed = speed * this.speedModifier;
					this.buildings.forEach((b) => (b.x -= realSpeed));

					// Lógica infinita
					if (this.buildings[0].x + this.buildings[0].width < 0) {
						this.buildings.shift();
						let last = this.buildings[this.buildings.length - 1];
						this.addBuilding(last.x + last.width);
					}
				}

				draw(context) {
					if (this.image.complete) {
						this.buildings.forEach((b) => {
							context.drawImage(
								b.img,
								b.sx,
								b.sy,
								b.sw,
								b.sh,
								b.x,
								b.y,
								b.width,
								b.height
							);
						});
					}
				}
			}

			// --- CHÃO ---
			class Ground {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.image = new Image();
					this.image.src = "street_ground.png";
					this.x = 0;
					this.groundHeight = 50;
				}

				update(speed) {
					this.x -= speed;
					if (this.x <= -2400) this.x = 0; // Reseta a posição da textura
				}

				draw(context) {
					if (this.image.complete) {
						let pattern = context.createPattern(
							this.image,
							"repeat"
						);
						context.fillStyle = pattern;
						context.save();
						context.translate(this.x, 0);
						context.fillRect(
							-this.x,
							this.gameHeight - this.groundHeight,
							this.gameWidth,
							this.groundHeight
						);
						context.restore();
					}
				}
			}

			// =================================================================
			// 3. CLASSE COIN (MOEDA) - Altura Ajustada
			// =================================================================
			class Coin {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.image = new Image();
					this.image.src = "sprite_coin.png";

					this.spriteW = 72;
					this.spriteH = 72;

					this.width = 40;
					this.height = 40;

					this.frameX = 0;
					this.maxFrame = 8;
					this.frameTimer = 0;
					this.frameInterval = 80;

					this.markedForDeletion = false;

					this.x = this.gameWidth;

					// --- CORREÇÃO DE ALTURA ---
					// O chão é 600 - 50 = 550. O Mario pula uns 150px.
					// Vamos limitar entre 300 (alto) e 450 (baixo/pulo curto)
					this.y = Math.random() * (450 - 300) + 300;
				}

				update(deltaTime, speed) {
					this.x -= speed;

					this.frameTimer += deltaTime;
					if (this.frameTimer > this.frameInterval) {
						this.frameX < this.maxFrame - 1
							? this.frameX++
							: (this.frameX = 0);
						this.frameTimer = 0;
					}

					if (this.x < -this.width) this.markedForDeletion = true;
				}

				draw(context) {
					if (!this.image.complete) return;

					context.drawImage(
						this.image,
						this.frameX * this.spriteW,
						0,
						this.spriteW,
						this.spriteH,
						this.x,
						this.y,
						this.width,
						this.height
					);
				}
			} // =================================================================
			// 4. CLASSE PEACH (INTRODUÇÃO)
			// =================================================================
			class Peach {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.image = new Image();
					this.image.src = "sprite_peach.png";

					this.spriteW = 72;
					this.spriteH = 144;
					this.frameX = 0;
					this.maxFrame = 8;
					this.frameTimer = 0;
					this.frameInterval = 100;

					this.width = 72;
					this.height = 144;
					this.x = -100;
					this.y = this.gameHeight - 50 - this.height + 10;
					this.speed = 1.5; // Anda devagar
				}

				update(deltaTime) {
					this.x += this.speed;
					this.frameTimer += deltaTime;
					if (this.frameTimer > this.frameInterval) {
						this.frameX < this.maxFrame - 1
							? this.frameX++
							: (this.frameX = 0);
						this.frameTimer = 0;
					}
				}

				draw(context) {
					if (this.image.complete) {
						context.drawImage(
							this.image,
							this.frameX * this.spriteW,
							0,
							this.spriteW,
							this.spriteH,
							this.x,
							this.y,
							this.width,
							this.height
						);
					}
				}
			}

			// =================================================================
			// 4. CLASSE PLAYER (MARIO)
			// =================================================================
			class Player {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.spriteWidth = 144;
					this.spriteHeight = 144;
					this.width = 100;
					this.height = 100;
					this.image = new Image();
					this.image.src = "player_brazil_flower.png";
					this.states = {
						IDLE: { row: 0, maxFrame: 3, fps: 0 },
						RUNNING: { row: 1, maxFrame: 7, fps: 20 },
						JUMPING: { row: 2, maxFrame: 1, fps: 0 },
						CROUCHING: { row: 3, maxFrame: 0, fps: 0 },
					};
					this.currentState = this.states.IDLE;
					this.frameX = 0;
					this.frameY = 0;
					this.maxFrame = 0;
					this.frameTimer = 0;
					this.fps = 20;
					this.frameInterval = 1000 / this.fps;
					this.x = -150; // Começa fora
					this.y = this.gameHeight - this.height - 50;
					this.vx = 0;
					this.vy = 0;
					this.weight = 1;
					this.speed = 0;
					this.maxSpeed = 6;
					this.facingRight = true;
				}

				update(input, deltaTime, audio) {
					let newState = this.states.IDLE;

					if (!this.onGround()) {
						newState = this.states.JUMPING;
						if (this.vy < 0) this.frameX = 0;
						else this.frameX = 1;
					} else if (input.keys.includes("ArrowDown")) {
						newState = this.states.CROUCHING;
						this.speed = 0;
					} else if (
						input.keys.includes("ArrowRight") ||
						input.keys.includes("ArrowLeft")
					) {
						newState = this.states.RUNNING;
						if (input.keys.includes("ArrowRight")) {
							this.speed = this.maxSpeed;
							this.facingRight = true;
						} else {
							this.speed = -this.maxSpeed;
							this.facingRight = false;
						}
					} else {
						this.speed = 0;
						newState = this.states.IDLE;
					}

					// TOCA SOM AO PULAR
					if (
						input.keys.includes("ArrowUp") &&
						this.onGround() &&
						newState !== this.states.CROUCHING
					) {
						this.vy -= 18;
						if (audio) audio.playJump();
					}

					if (this.frameY !== newState.row) {
						this.frameY = newState.row;
						this.maxFrame = newState.maxFrame;
						this.fps = newState.fps;
						this.frameInterval = 1000 / (this.fps || 60);
						this.frameX = 0;
						this.frameTimer = 0;
					}
					this.x += this.speed;
					if (this.x < 0) this.x = 0;

					this.y += this.vy;
					if (!this.onGround()) {
						this.vy += this.weight;
					} else {
						this.vy = 0;
					}
					if (this.y > this.gameHeight - this.height - 50) {
						this.y = this.gameHeight - this.height - 50;
					}
					if (this.fps > 0) {
						if (this.frameTimer > this.frameInterval) {
							this.frameX < this.maxFrame
								? this.frameX++
								: (this.frameX = 0);
							this.frameTimer = 0;
						} else {
							this.frameTimer += deltaTime;
						}
					}
				}
				draw(context) {
					if (this.facingRight) {
						context.drawImage(
							this.image,
							this.frameX * this.spriteWidth,
							this.frameY * this.spriteHeight,
							this.spriteWidth,
							this.spriteHeight,
							this.x,
							this.y,
							this.width,
							this.height
						);
					} else {
						context.save();
						context.translate(this.x + this.width, this.y);
						context.scale(-1, 1);
						context.drawImage(
							this.image,
							this.frameX * this.spriteWidth,
							this.frameY * this.spriteHeight,
							this.spriteWidth,
							this.spriteHeight,
							0,
							0,
							this.width,
							this.height
						);
						context.restore();
					}
				}
				onGround() {
					return this.y >= this.gameHeight - this.height - 50;
				}
			}

			// =================================================================
			// 6. CLASSES INIMIGOS
			// =================================================================

			// Classe Base
			class Enemy {
				constructor(gameWidth, gameHeight) {
					this.gameWidth = gameWidth;
					this.gameHeight = gameHeight;
					this.markedForDeletion = false;
					this.image = new Image();
					this.image.src = "sprites_enemies.png";

					this.gridSize = 72;
					this.spriteW = 144;
					this.spriteH = 72; // Padrão

					this.frameTimer = 0;
					this.frameX = 0;
					this.frameY = 0;
					this.maxFrame = 5;
					this.frameInterval = 100;
					this.speedX = 2;

					this.width = 80;
					this.height = 40;
				}

				update(deltaTime, speed) {
					this.x -= this.speedX + speed;
					if (this.x < -this.width) this.markedForDeletion = true;

					this.frameTimer += deltaTime;
					if (this.frameTimer > this.frameInterval) {
						if (this.frameX < this.maxFrame - 1) this.frameX++;
						else this.frameX = 0;
						this.frameTimer = 0;
					}
				}

				draw(context) {
					if (this.image.complete) {
						context.drawImage(
							this.image,
							this.frameX * this.spriteW,
							this.frameY * this.gridSize,
							this.spriteW,
							this.spriteH,
							this.x,
							this.y,
							this.width,
							this.height
						);
					}
				}
			}

			class Pigeon extends Enemy {
				constructor(gameWidth, gameHeight) {
					super(gameWidth, gameHeight);
					this.frameY = 0;
					this.spriteH = 144;
					this.maxFrame = 6;
					this.width = 90;
					this.height = 90;
					this.x = this.gameWidth;
					this.y = Math.random() * (this.gameHeight - 300) + 50;
					this.speedX = 1.5;
					this.angle = 0;
				}
				update(dt, s) {
					super.update(dt, s);
					this.angle += 0.05;
					this.y += Math.sin(this.angle) * 2;
				}
			}

			class Snail extends Enemy {
				constructor(gameWidth, gameHeight) {
					super(gameWidth, gameHeight);
					this.frameY = 2;
					this.spriteH = 72;
					this.maxFrame = 7;
					this.width = 80;
					this.height = 40;
					this.x = this.gameWidth;
					this.y = this.gameHeight - 45 - 40;
					this.speedX = 0.5;
				}
			}

			class Rat extends Enemy {
				constructor(gameWidth, gameHeight) {
					super(gameWidth, gameHeight);
					this.frameY = 3;
					this.spriteH = 72;
					this.maxFrame = 8;
					this.width = 80;
					this.height = 40;
					this.x = this.gameWidth;
					this.y = this.gameHeight - 50 - 40;
					this.speedX = 2;
				}
			}

			class Waiter extends Enemy {
				constructor(gameWidth, gameHeight) {
					super(gameWidth, gameHeight);
					this.frameY = 4;
					this.spriteH = 144;
					this.maxFrame = 7;
					this.width = 80;
					this.height = 110;
					this.x = this.gameWidth;
					this.y = this.gameHeight - 50 - 110 + 10;
					this.speedX = 2.5;
				}
			}

			class Gargoyle extends Enemy {
				constructor(gameWidth, gameHeight) {
					super(gameWidth, gameHeight);
					this.frameY = 6;
					this.spriteH = 144;
					this.maxFrame = 8;
					this.width = 100;
					this.height = 100;
					this.x = this.gameWidth;
					this.y = 50;
					this.speedX = 1.5;
					this.angle = 0;
					this.diveSpeed = 0.01;
				}
				update(dt, s) {
					super.update(dt, s);
					this.angle += this.diveSpeed;
					if (this.angle < Math.PI) {
						this.y = 50 + Math.sin(this.angle) * 350;
					} else {
						this.y = 50;
					}
				}
			}

			// =================================================================
			// 7. CLASSE GAME (MAESTRO) - Correções Aplicadas
			// =================================================================
			class Game {
				constructor(width, height) {
					this.width = width;
					this.height = height;
					this.audio = new AudioHandler();
					this.input = new InputHandler();

					this.sky = new Sky(this.width, this.height);
					this.background = new Background(this.width, this.height);
					this.fillerBackground = new FillerBackground(
						this.width,
						this.height
					);
					this.ground = new Ground(this.width, this.height);

					this.player = new Player(this.width, this.height);
					this.peach = new Peach(this.width, this.height);

					this.introState = 1;

					this.enemies = [];
					this.coins = [];

					this.enemyTimer = 0;
					this.enemyInterval = 1000;

					this.coinTimer = 0;
					this.coinInterval = 1500;

					this.score = 0;
					this.gameOver = false;
				}

				update(deltaTime) {
					if (this.gameOver) return;

					// --- [NOVO] CONDIÇÃO DE VITÓRIA ---
					if (this.score >= 20 && this.introState === 0) {
						this.introState = 3; // Ativa Modo Final
						this.enemies = []; // Remove inimigos imediatamente
						this.coins = [];
						this.audio.stopMusic(); // Para a música do jogo
					}

					// --- MODO FINAL (COM GRAVIDADE) ---
					if (this.introState === 3) {
						this.updateEnvironment(0.5);
						this.player.x += 2; // Anda pra direita

						// *** GRAVIDADE ***
						this.player.y += this.player.vy;
						if (!this.player.onGround()) {
							this.player.vy += this.player.weight;
							this.player.frameX = 1;
							this.player.frameY = 2; // Frame de pulo/queda
						} else {
							this.player.vy = 0;
							this.player.y = this.height - 150;
							// Animação correndo
							this.player.frameY = 1;
							this.player.frameTimer += deltaTime;
							if (this.player.frameTimer > 50) {
								this.player.frameX < 7
									? this.player.frameX++
									: (this.player.frameX = 0);
								this.player.frameTimer = 0;
							}
						}

						if (this.player.x > this.width) {
							canvas.style.display = "none";
							videoElement.style.display = "block";
							videoElement.play();
							this.gameOver = true;
						}
						return;
					}
					// --- INTRO LÓGICA ---
					if (this.introState === 1) {
						this.peach.update(deltaTime);
						this.updateEnvironment(0.5);
						if (this.peach.x > 600) this.audio.fadeOutPeachTheme();
						if (this.peach.x > this.width + 50) this.introState = 2;
						return;
					}

					if (this.introState === 2) {
						this.updateEnvironment(0.5);
						this.player.x += 2;
						this.player.frameY = 1;
						this.player.frameTimer += deltaTime;
						if (this.player.frameTimer > 50) {
							this.player.frameX < 7
								? this.player.frameX++
								: (this.player.frameX = 0);
							this.player.frameTimer = 0;
						}
						if (this.player.x >= 100) {
							this.player.x = 100;
							this.player.frameY = 0;
							this.introState = 0;
							this.audio.playMusic();
						}
						return;
					}

					// --- JOGO ---
					this.player.update(this.input, deltaTime, this.audio);

					let speed = 0;
					if (
						this.player.x > this.width / 2 &&
						this.player.speed > 0
					) {
						this.player.x = this.width / 2;
						speed = this.player.speed;
					}

					this.updateEnvironment(speed);

					this.enemies.forEach((e) => e.update(deltaTime, speed));
					this.coins.forEach((c) => c.update(deltaTime, speed));

					// SPAWN INIMIGOS
					if (this.enemies.length === 0) {
						this.enemyTimer += deltaTime;
						if (this.enemyTimer > this.enemyInterval) {
							this.addEnemy();
							this.enemyTimer = 0;
						}
					}

					// SPAWN MOEDAS (CORRIGIDO: EVITAR DUPLAS)
					this.coinTimer += deltaTime;
					if (this.coinTimer > this.coinInterval) {
						// Só adiciona se não houver moeda muito perto da borda direita (últimos 300px)
						// Isso evita que venham duas coladas
						const lastCoin = this.coins[this.coins.length - 1];
						const safeDistance =
							!lastCoin || this.width - lastCoin.x > 300;

						if (safeDistance) {
							this.coins.push(new Coin(this.width, this.height));
							this.coinTimer = 0;
							this.coinInterval = Math.random() * 2000 + 1000;
						}
					}

					// LIMPEZA E COLISÃO
					this.enemies = this.enemies.filter(
						(e) => !e.markedForDeletion
					);
					this.coins = this.coins.filter((c) => !c.markedForDeletion);

					this.coins.forEach((c) => {
						if (
							!c.markedForDeletion &&
							this.checkCollision(this.player, c)
						) {
							c.markedForDeletion = true;
							this.score++;
							this.audio.playCoin();
						}
					});

					this.enemies.forEach((e) => {
						if (
							this.player.x + 30 < e.x + e.width - 20 &&
							this.player.x + this.player.width - 40 > e.x + 20 &&
							this.player.y + 30 < e.y + e.height - 10 &&
							this.player.y + this.player.height > e.y + 20
						) {
							this.gameOver = true;
							this.audio.playGameOver();
						}
					});
				}

				updateEnvironment(speed) {
					this.sky.update(0.5);
					let backgroundSpeed = speed > 0 ? speed : 0.2;
					this.background.update(backgroundSpeed);
					this.fillerBackground.update(speed);
					this.ground.update(speed);
				}

				draw(context) {
					this.sky.draw(context);
					this.background.draw(context);
					this.fillerBackground.draw(context);
					this.ground.draw(context);

					if (this.introState === 1) {
						this.peach.draw(context);
					} else if (this.introState === 2 || this.introState === 3) {
						this.player.draw(context);
					} else {
						this.coins.forEach((c) => c.draw(context));
						this.enemies.forEach((e) => e.draw(context));
						this.player.draw(context);

						// --- CORREÇÃO DE PLACAR ---
						// Forçamos o alinhamento para esquerda antes de desenhar o score
						context.textAlign = "left";
						context.fillStyle = "gold";
						context.font = "30px 'Courier New'";
						context.strokeStyle = "black";
						context.lineWidth = 4;
						context.strokeText("COINS: " + this.score, 20, 50);
						context.fillText("COINS: " + this.score, 20, 50);
					}

					if (this.gameOver) {
						// Aqui mudamos para Center, por isso bugava antes no próximo frame
						context.textAlign = "center";
						context.fillStyle = "black";
						context.font = "50px Impact";
						context.fillText(
							"GAME OVER",
							this.width / 2,
							this.height / 2
						);
						context.fillStyle = "white";
						context.fillText(
							"GAME OVER",
							this.width / 2 - 3,
							this.height / 2 - 3
						);

						context.font = "20px 'Courier New'";
						context.fillStyle = "white";
						context.fillText(
							"Score: " + this.score,
							this.width / 2,
							this.height / 2 + 40
						);
						context.fillText(
							"Press SPACE to reset",
							this.width / 2,
							this.height / 2 + 80
						);
					}
				}

				checkCollision(rect1, rect2) {
					return (
						rect1.x < rect2.x + rect2.width &&
						rect1.x + rect1.width > rect2.x &&
						rect1.y < rect2.y + rect2.height &&
						rect1.y + rect1.height > rect2.y
					);
				}

				addEnemy() {
					const r = Math.random();
					if (r < 0.2)
						this.enemies.push(new Snail(this.width, this.height));
					else if (r < 0.4)
						this.enemies.push(new Rat(this.width, this.height));
					else if (r < 0.6)
						this.enemies.push(new Pigeon(this.width, this.height));
					else if (r < 0.8)
						this.enemies.push(new Waiter(this.width, this.height));
					else
						this.enemies.push(
							new Gargoyle(this.width, this.height)
						);
				}

				restart() {
					this.player.x = 100;
					this.player.y = this.height - 150;
					this.player.frameY = 0;
					this.enemies = [];
					this.coins = [];
					this.enemyTimer = 0;
					this.score = 0;
					this.gameOver = false;
					this.introState = 0;

					this.audio.stopPeachThemeImmediate();
					this.audio.playMusic();
				}
			}
			// =================================================================
			// INICIALIZAÇÃO E LOOP PRINCIPAL
			// =================================================================
			const game = new Game(canvas.width, canvas.height);
			let lastTime = 0;
			let gameStarted = false; // NOVA VARIÁVEL DE CONTROLE

			// LÓGICA DO BOTÃO INICIAR
			const startScreen = document.getElementById("startScreen");

			startScreen.addEventListener("click", () => {
				// 1. Esconde a tela
				startScreen.style.display = "none";

				// 2. Toca a música da Peach IMEDIATAMENTE (o navegador permite agora)
				game.audio.playPeachTheme();

				// 3. Libera o jogo
				gameStarted = true;
				lastTime = performance.now();
				animate(lastTime);
			});

			// ESCUTA O REINÍCIO (Espaço)
			window.addEventListener("keydown", (e) => {
				if (e.key === " " && game.gameOver) {
					game.restart();
				}
			});

			function animate(timeStamp) {
				if (!gameStarted) return; // Se não clicou, não roda nada

				const deltaTime = timeStamp - lastTime;
				lastTime = timeStamp;

				ctx.clearRect(0, 0, canvas.width, canvas.height);
				game.update(deltaTime);
				game.draw(ctx);

				requestAnimationFrame(animate);
			}
		</script>
	</body>
</html>
